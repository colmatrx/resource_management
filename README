#########################   AUTHOR: IDRIS ADELEKE #######################
                            CS4760 PROJECT 5 SUBMITTED DECEMBER 1, 2021

This program runsim is compiled with the command 'make clean'.
This program is run in this format: ./runsim [n] < [input file] where n >= 2
for example ./runsim 5 < testing.data; 5 is the number of licenses available for the parent and concurrent child (testsim) processes and testing.data is the input file.
Note that the number of licenses n should be greater than or equal to 2 because the parent process keeps 1 license to consecutively fork all the child processes while the rest is shared among the child processes.

This program was tested with 6 lines of input in the testing.data file and all completed before the timeout limit of 100 seconds.

Two message queues are implemented. One for controlling access to the license object and one for controlling access to the logfile.log

Additional logfile named 'log' was used in the final test to show the example of verbose output. It was generated by redirecting the output from the terminal so the output are not as ordered as when viewed on the terminal. Please run this program without output redirection so proper output can be viewed on the terminal.
Appropriate delay has been implemented in runsim to accommodate for reasonable visibility of the output on the terminal during execution.

The function initlicense() and initlogfile() were called once in the beginning and by the parent process to initialize the license and logfile message queues.

They both write to the message queue with an IPC_NOWAIT option since they are performing initialization.

The function getlicense() is used in a blocking receive mode and if successful immmediately calls removelicense() to subtract 1 from the license object.

The function returnlicense() is called by the parent to add 1 to the license object whenever a child process completes execution.

returnlicense() is called with a no wait option so that in the event it fails, that is all the licenses are in use, then it should still be able to return the current license by writing 1 back to the queue.

The function addtolicenses() is defined and declared but not called in any part of the program.

The function logmsg() is called by both the parent and child processes in order to write to the file. A process that reads 1 from the logging message queue gets to have the write access to the logfile while the rest wait for it to finish writing. This allows for an ordered output to the log.

Finally, child processes prints out messages as they wait for, obtain and return licenses to run.
Each process announces its process id, sleep iteration and execution completion.
The parent process waits for all child processes to finish, then removes the 2 message queues. This is verified by the ipcs command.

This program also catches the Ctrl+C signal and times out after 100 seconds. If this happens, it kills pending child processes and removes the message queues before terminating itself.

In the end, the correctness of the program is verified by comparing the licenses after execution to the license provided at program launch.
If they are the same, there was no race condition on the license object and concurrency was successfully implemented.